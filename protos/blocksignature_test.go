// Copyright (c) 2018-2020. The asimov developers
// Use of this source code is governed by an ISC
// license that can be found in the LICENSE file.

package protos

import (
	"bytes"
	"reflect"
	"testing"
	"github.com/AsimovNetwork/asimov/common"
)


//signed block hash
var signedBlockHash = common.Hash([common.HashLength]byte{
	0x6f, 0xe2, 0x8c, 0x0a, 0xb6, 0xf1, 0xb3, 0x72,
	0xc1, 0xa6, 0xa2, 0x46, 0xae, 0x63, 0xf7, 0x4f,
	0x93, 0x1e, 0x83, 0x65, 0xe1, 0x5a, 0x08, 0x9c,
	0x68, 0xd6, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00,
})

// TestMsgBlockSignSerialize tests MsgBlockSign serialize and deserialize.
func TestMsgBlockSignSerialize(t *testing.T) {
	msgBlkSign := &MsgBlockSign{
		BlockHeight:1,
		BlockHash:signedBlockHash,
		Signer:common.Address{0x9f, 0xb8, 0xaa, 0x4b, 0xa2, 0x46, 0xae, 0x63, 0x9f, 0xb8, 0xaa, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x0a, 0xb6, 0xf1, 0xb3, 0x72,},
		Signature: [HashSignLen]byte{0x63, 0xe3, 0x83, 0x03, 0xb3, 0xf3, 0xb3, 0x73, 0x83},
	}
	msgBlkSignEncoded := []byte{
		0x01, 0x00, 0x00, 0x00, // blockHeight
		0x6f, 0xe2, 0x8c, 0x0a, 0xb6, 0xf1, 0xb3, 0x72,
		0xc1, 0xa6, 0xa2, 0x46, 0xae, 0x63, 0xf7, 0x4f,
		0x93, 0x1e, 0x83, 0x65, 0xe1, 0x5a, 0x08, 0x9c,
		0x68, 0xd6, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, //signedBlockHash
		0x9f, 0xb8, 0xaa, 0x4b, 0xa2, 0x46, 0xae, 0x63, 0x9f, 0xb8, 0xaa, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x0a, 0xb6, 0xf1, 0xb3, 0x72,  //signer
		0x63, 0xe3, 0x83, 0x03, 0xb3, 0xf3, 0xb3, 0x73, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //signature
	}

	tests := []struct {
		in  *MsgBlockSign // Data to encode
		out *MsgBlockSign // Expected decoded data
		buf []byte       // Serialized data
	}{
		{
			msgBlkSign,
			msgBlkSign,
			msgBlkSignEncoded,
		},
	}

	t.Logf("Running %d tests", len(tests))
	for i, test := range tests {
		// Serialize the block sign.
		var buf bytes.Buffer
		err := test.in.Serialize(&buf)
		if err != nil {
			t.Errorf("Serialize #%d error %v", i, err)
			continue
		}
		if !bytes.Equal(buf.Bytes(), test.buf) {
			t.Errorf("Serialize #%d\n got: %v want: %v", i,
				buf.Bytes(), test.buf)
			continue
		}

		// Deserialize the block sign.
		var msgBlkSignEncode MsgBlockSign
		rbuf := bytes.NewReader(test.buf)
		err = msgBlkSignEncode.Deserialize(rbuf)
		if err != nil {
			t.Errorf("Deserialize #%d error %v", i, err)
			continue
		}
		if !reflect.DeepEqual(&msgBlkSignEncode, test.out) {
			t.Errorf("Deserialize #%d\n got: %v want: %v", i,
				&msgBlkSignEncode, test.out)
			continue
		}
	}
}
